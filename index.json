[{"content":" Python Bases du langage Ruby Bases du langage Programmation Orientée Objet Modules, namespaces et mixins ","description":"","tags":null,"title":"Back-end","uri":"/developpement/backend/index.html"},{"content":"Variables Types Integer 1234 Float 3.14 String 'string' ou \"string\" Boolean True et False En Python, le type null est None.\nMéthodes utiles pour convertir les types int() : conversion en Integer float() : conversion en Float str() : conversion en String Déclaration d’une variable En Python les variables ont un typage faible et peuvent changer de type à volonté.\nma_variable = \"Chaine de caractères\" Inclusion de variable dans une string : Concaténation : variable = \"World\" \"Hello, \" + variable + \" !\" # str(variable) si besoin de convertir Opérateur “%” :\n%s pour les strings %d pour les nombres variable1 = \"My\" variable2 = \"World\" \"Hello, %s %s !\"%(variable1, variable2) Fonction format() : variable = \"World\" \"Hello, {} !\".format(variable) f-string (Python \u003e= 3.6) : variable = \"World\" f\"Hello, {variable} !\" Entrées/Sorties print() affiche une chaîne de caractères à l’écran\ninput() récupère une entrée utilisateur (ne garde pas de saut de ligne de fin)\nnom = input() print(f\"Bonjour {nom} !\") Commentaires Commentaires sur une ligne En Python, un commentaire sur une ligne est défini par le caractère #.\n# Ceci est un commentaire Commentaires sur plusieurs lignes Il est possible de définir un bloc de commentaires pouvant tenir sur plusieurs lignes en l’entourant de \"\"\".\n\"\"\" Ceci est un bloc de commentaires pouvant tenir sur plusieurs lignes. \"\"\" Conditions Bloc if-elif-else if \u003ccondition\u003e: instruction elif \u003ccondition\u003e: instruction else: instruction Il est possible de combiner les conditions avec and, or et not.\nTernaire En Python, les conditions ternaires s’écrivent avec un if et un else sur une ligne :\nresult = \"ok\" if a \u003c b else \"ko\" Boucles Boucle while while test: handle_true() else: handle_false() # Run if didn't exit loop with break Boucle for for x in range(5): # range(5) = 0, 1, 2, 3, 4 print(x) Opérations sur les boucles Ne rien faire L’opérateur pass ne fait rien. Il permet d’indiquer explicitement au programme qu’il ne doit rien se passer.\nfor x in range(5): if x == 3: pass else: print(x) Arrêter la boucle L’opérateur break permet de sortir d’une boucle.\nfor x in range(5): if x == 3: break Sauter une itération L’opérateur continue permet de passer directement à l’itération suivante.\nfor x in range(5): continue if x == 3 print(x) Listes et tuples Listes Déclaration d’une liste et accès à un élément tableau = [1, 2, '3', '4'] # Un tableau peut contenir des éléments de types différents print(tableau[0]) # 1 tableau = list(1, 2, '3', '4') print(tableau[0]) # 1 Ajout d’un élément à un tableau Pour ajouter un élément à un tableau, trois méthodes sont disponibles : append pour ajouter un élément, insert qui ajoute un élément à un index précis et enfin extend qui permet d’ajouter une liste d’éléments.\ntableau.append('5') tableau.insert(1, '6') tableau.extend(['7', '8']) Retrait d’un élément du tableau Pour retirer un élément d’un tableau, trois méthodes sont disponibles : remove qui prend l’élément à supprimer, pop qui prend l’index de l’élément à supprimer ou supprime le dernier élément si non fourni et enfin clear qui supprime l’intégralité des éléments de la liste.\nnum = ['one', 'two', 'three', 'four'] num.remove('one') # ['two', 'three', 'four'] num.pop() # ['two', 'three'] num.clear() # [] Connaître la taille d’un tableau La méthode len() permet de connaître le nombre d’éléments présents dans un tableau.\ntableau = [1, 2, 3, 4] print(len(tableau)) # 4 Trier un tableau La méthode sort() permet de trier un tableau par ordre croissant.\ntableau = [2, 3, 1, 4] print(tableau.sort()) # [1, 2, 3, 4] Info De nombreuses autres méthodes utiles aux tableaux sont présentées dans la documentation officielle.\nTuples Les tuples sont des structures de données similaires aux tableau à la différence qu’ils sont immutables, contrairement aux tableau qui, eux, peuvent être modifiés.\nIls se déclarent entre parenthèses ().\nmon_tuple = (1, 2) Dictionnaires Déclaration d’un dictionnaire et accès à un élément dico = { 'key': 'value' } print(dico['key']) # value print(dico['inexistingKey']) # =\u003e KeyError Il est aussi possible d’utiliser la fonction dict() :\ndico = dict( key: 'value' ) print(dico['key']) # value print(dico['inexistingKey']) # =\u003e KeyError Ajout d’un élément dans un dictionnaire dico['otherKey'] = 'otherValue' Suppression d’un élément d’un dictionnaire Pour supprimer un élément d’un dictionnaire, il suffit d’utiliser le mot-clé del en précisant l’élément à supprimer.\ndico = dict( key: 'value' ) del dico['key'] Vérification de l’existence d’une clé Il est possible d’utiliser le mot-clé in pour tester l’existance d’une clé dans un dictionnaire.\ndico = dict( key: 'value' ) if 'key' in dico: print(dico['key']) Fonctions Définir une fonction def add(a, b): return a + b En l’absence d’instruction return, une fonction renverra toujours None.\nRetour multiple En Python, il est possible de retourner plusieurs valeurs d’une fonction. Il suffit de les séparer par des virgules et le retour est ainsi récupérable sous forme de tuple.\ndef test_func(num1, num2): return num1, num2 a, b = test_func(5, 10) Paramètres nommés def test_func(num1, num2): return num1, num2 a, b = test_func(num1=5, num2=10) Paramètres optionnels Il est possible de rendre un paramètre optionnel en précisant sa valeur par defaut\ndef test_func(num1, num2=10): return num1, num2 a, b = test_func(5) Liste de paramètres def nom_fonction(*args) print(type(args)) # \u003cclass 'tuple'\u003e Il est toujours possible de passer des paramètres “isolés” en les mettant avant la liste.\nLambda Python supporte les fonctions anonymes, aussi appelées lambda.\nlambda arguments: expression Lire et écrire des fichiers Ouverture et fermeture d’un fichier En Python, il est possible d’ouvrir un fichier en lecture ou en écriture avec la méthode open().\nf = open(\"myfile.csv\") Il peut être utile de préciser le mode dans lequel on souhaite ouvrir le fichier :\nf = open(\"myfile.csv\") # This is the same as “rt” mode. f = open(\"myfile.csv\", \"w\") # write in text mode f = open(\"myimage.png\", \"r+b\") # read and write in binary mode Voici la liste des options possibles :\nOption Description “r” read mode (default) “w” write mode “x” exclusive creation (fails if file already exists) “t” text mode (default) “b” binary mode “a” appending data at the end (create file if doesn’t exist) “+” update file (reading and writing) Après utilisation, il est nécessaire de fermer le fichier à l’aide de la méthode close().\nf = open(\"myfile.csv\") f.close() Le mot-clé with permet d’ouvrir un bloc dans lequel un fichier est ouvert au début et automatiquement fermé à la fin.\nwith open(\"myfile.csv\") as f: \u003cinstructions\u003e Lecture d’un fichier Lecture complète sous forme de texte La méthode read() permet de lire l’entièreté d’un fichier sous la forme d’un string.\nwith open(\"myfile.csv\") as f: content = f.read() Info La méthode read() retourne une ligne vide quand elle arrive à la fin du fichier. Pour la supprimer il est possible d’utiliser la méthode rstrip()\nLecture ligne par ligne Il est possible de parcourir un fichier ligne par ligne en itérant dessus avec une boucle for\nwith open(\"myfile.csv\") as f: for line in f: print(line) Info Comme précédemment, cette méthode retourne une ligne vide après chaque ligne lue. Pour la supprimer il est possible d’utiliser la méthode rstrip()\nRécupération du contenu sous forme de liste La méthode readlines() permet de récupérer l’entièreté des lignes du fichier sous forme de liste.\nwith open(\"myfile.csv\") as f: lines = f.readlines() Écriture dans un fichier La méthode write() permet d’écrire une ligne dans un fichier.\nwith open(\"myfile.csv\") as f: f.write(\"new line\") Info La méthode write() n’ajoute pas de retour à la ligne en fin de texte. Il est nécessaire, si besoin, d’ajouter manuellemenet un \\n.\n","description":"","tags":["python"],"title":"Bases du langage","uri":"/developpement/backend/python/basics/index.html"},{"content":"Variables Types Integer 1234 Float 3.14 String 'string' ou \"string\" Boolean true et false En Ruby, le type null est nil.\nMéthodes utiles pour convertir les types to_i : conversion en Integer to_f : conversion en Float to_s : conversion en String Vérifier qu’une variable est d’un certain type En Ruby, on vérifie rarement le type d’une variable, on utilise plutôt la méthode respond_to? afin de vérifier qu’on puisse lui appliquer une certaine méthode.\ndef to_up(text) if text.respond_to?(:to_s) text.to_s.upcase end end Déclaration d’une variable En Ruby, les variables ont un typage faible et peuvent changer de type à volonté.\nma_variable = 'Chaine de caractères' Inclusion de variable dans une string :\n\"Ceci est une chaine de caractères contenant une #{variable}\" Il est possible de déclarer des variables de manière globale en la plaçant en dehors de tout bloc et en utilisant le signe $.\n$variable_globale = \"Hello, world !\" Et pour finir, il est possible de déclarer des constantes en écrivant leur nom tout en majuscule.\nMA_CONSTANTE = 1 Entrées/Sorties puts affiche une chaîne de caractères à l’écran (avec saut de ligne)\nprint affiche une chaîne de caractères à l’écran (sans saut de ligne)\ngets récupère une entrée utilisateur (garde le saut de ligne de fin) utliser la méthode chomp pour supprimer le saut de ligne final\nnom = gets.chomp puts \"Bonjour #{nom} !\" Commentaires Commentaires sur une ligne En Ruby, un commentaire sur une ligne est défini par le caractère #.\n# Ceci est un commentaire Commentaires sur plusieurs lignes Il est possible de définir un bloc de commentaires pouvant tenir sur plusieurs lignes à l’aide de =begin et =end.\n=begin Ceci est un bloc de commentaires pouvant tenir sur plusieurs lignes. =end Conditions Bloc if-elsif-else if \u003ccondition\u003e instruction elsif \u003ccondition\u003e instruction else instruction end unless condition est équivalent à if !condition\nUne condition if peut s’écrire sur une ligne :\nputs \"Condition vraie\" if \u003ccondition\u003e puts \"Condition fausse\" unless \u003ccondition\u003e Il est possible de combiner les conditions avec \u0026\u0026, || et !.\nBloc case-when var = 1 case var when 1 puts \"ok\" else puts \"ko\" end Il existe une version raccourcie :\nvar = 1 case var when 1 then puts \"ok\" end Ternaire En Ruby, les conditions ternaires s’écrivent comme dans tous les autres langages :\nputs a \u003c b ? \"ok\" : \"ko\" Operateurs conditionnels || renvoie la 1ère valeur si truthy et la 2ème sinon.\na = false b = \"Salut\" puts a || b # Salut a = \"Hello\" puts a || b # Hello Affectation conditionnelle a = false a ||= \"Valeur par defaut\" puts a # Valeur par defaut a = \"Hello\" a ||= \"Valeur par defaut\" puts a # Hello Boucles Boucle while while \u003ccondition\u003e # until !\u003ccondition\u003e ... end Boucle for for num in 1..10 # 1..10 = [1, 10] et 1...10 = [1, 10[ puts num end Sauter une itération for num in 1..10 next if num == 3 puts num end Boucle loop (Infinie) loop do ... break if \u003ccondition\u003e end Tableaux Déclaration d’un tableau et accès à un élément tableau = [1, 2, '3', '4'] # Un tableau peut contenir des éléments de types différents puts tableau[0] # 1 Ajout d’un élément à un tableau Pour ajouter un élément à un tableau, on peut utiliser la concaténation d’un autre tableau avec l’opérateur +, les chevrons («) ou la méthode push.\ntableau += ['5'] tableau \u003c\u003c '6' tableau.push '7' Retrait d’un élément du tableau On utilise la méthode pop de la classe Array\ntableau.pop Méthodes collect et map Ce sont deux fonctions identiques qui executent un bloc pour chaque élément d’un tableau et retournent le tableau resultant.\nHash Déclaration d’un Hash et accès à un élément hash = { 'key' =\u003e 'value' } puts hash['key'] # value puts hash['inexistingKey'] # nil Syntaxe plus moderne utilisant implicitement des symboles\nhash = { key: 'value' } hash[:key] # value puts hash[:inexistingKey] # nil En utilisant le constructeur et en spécifiant une valeur par défaut\nhash = Hash.new(0) puts hash[:inexistingKey] # 0 Ajout d’un élément dans un Hash hash['otherKey'] = 'otherValue' hash[:otherKey] = 'otherValue' Itérateurs Méthode times 3.times do |num| puts num end Méthode each array.each do |value| ... end hash.each do |key, value| ... end Fonctions Définir une fonction def nom_fonction(param) return param end En l’absence d’instruction return, une fonction renverra le résultat de sa dernière instruction.\nEn Ruby, on ne teste pas le type d’un paramètre mais on tente directement de le caster.\nConventions de nommage Les caractères spéciaux sont autorisés dans les noms de fonction ainsi que les symboles comme ‘+’, ‘-’… Traditionnellement, les fonctions possédant ces symboles implémentent les opérateurs correspondants.\n? : retourne un boolean ! : modifie l’objet Paramètres optionnels Il est possible de rendre un paramètre optionnel en précisant sa valeur par defaut\ndef nom_fonction(param = \"Valeur par defaut\") return param end Liste de paramètres def nom_fonction(*params) puts params.inspect # [param1, param2, ...] end Il est toujours possible de passer des paramètres “isolés” en les mettant avant la liste.\nProcs et Blocs Blocs Passer un bloc a une fonction Un bloc peut être passé à une fonction à l’aide du mot-clé yield.\ndef test puts \"A first text\" yield puts \"A third text\" end test { puts \"A second text\" } Un bloc peut être appelé plusieurs fois en mettant plusieurs yield dans la fonction.\nWarning À partir du moment où on met un yield dans une fonction, celle-ci va obligatoirement attendre un paramètre de type bloc.\nPasser un paramètre à un bloc Il est possible de passer un ou plusieurs paramètre(s) à yield. Ils seront automatiquement passés au bloc :\ndef test puts \"A first text\" yield(\"A second text\") puts \"A third text\" end test { |text| puts text } La limite des blocs est qu’ils ne peuvent pas être sauvegardés dans des variables. Empêcher ainsi de pouvoir les réutiliser à plusieurs endroits.\nProcs On peut voir les procs comme des blocs qu’on peut sauvegarder.\nCréation d’un Proc On peut créer un Proc avec Proc.new auquel on passe un bloc. Et on peut le sauvegarder dans une variable.\nvar = Proc.new { \u003cinstructions\u003e } Passage d’un Proc à une fonction Pour être passé en tant que bloc à une fonction, un Proc doit être ‘converti’ en bloc. Cela se fait avec le signe \u0026.\nmon_proc = Proc.new { \u003cinstructions\u003e } a = [1, 2, 3] a.map!(\u0026mon_proc) Appel direct d’un Proc Il est possible d’appeler à n’importe quel moment un Proc en utilisant la méthode call :\nmon_proc = Proc.new { |param| \u003cinstructions\u003e } mon_proc.call(\"param\") Récupérer dans une fonction un bloc sous forme de Proc Il est possible de récupérer un bloc sous forme de Proc dans une fonction à l’aide du même signe \u0026 :\ndef ma_fonction(\u0026bloc) # ici, bloc est un Proc bloc.call(\"param\") end ma_fonction { |param| \u003cinstructions\u003e } Info Contrairement aux blocs, il est possible de passer plusieurs Proc à une fonction !\nLambda En Ruby, un lambda est très similaire à un Proc.\nPour créer un lambda, il suffit de remplacer le Proc.new par lambda et lui passer un bloc.\nmon_lambda = lambda { |param| \u003cinstructions\u003e } puts mon_lambda.inspect # On se rend compte ici qu'un lambda est un Proc particulier Il s’utilise ensuite de la même façon qu’un Proc.\nDifférences entre Proc et lambda Un lambda vérifie le nombre de paramètres fournis, alors que le Proc n’effectue aucune vérification sur les paramètres. Dans un lambda, le return retourne au sein du bloc, alors que dans un Proc, il le comprend comme un return “classique”. def a_lambda a = lambda { return \"Salut\" } a.call # équivalent \"Salut\" return \"Au revoir\" end def a_proc a = Proc.new { return \"Salut\" } a.call # équivalent return \"Salut\" return \"Au revoir\" end a_lambda # Au revoir a_proc # Salut Nouvelle syntaxe du lambda mon_lambda = -\u003e(\u003cparam\u003e) { \u003cinstructions\u003e } Syntaxe raccourcie pour un appel de méthode sur chaque élément passé à un bloc a = [\"1\", \"2\", 3] a.map! { |n| n.to_i } # Syntaxe \"classique\" a.map!(\u0026:to_i) # Syntaxe raccourcie ","description":"","tags":["ruby"],"title":"Bases du langage","uri":"/developpement/backend/ruby/basics/index.html"},{"content":"System context diagram Container diagram Component diagram Code diagram Références https://c4model.com/ ","description":"","tags":["architecture-as-code","diagrams"],"title":"C4 Model","uri":"/architecture/c4/index.html"},{"content":"Introduction Les pipelines CI/CD permettent un passage simplifié et sécurisé du code en production. Ils doivent s’assurer qu’une application est correctement compilée/assemblée, testée et déployée.\nLe principal objectif d’un pipeline CI/CD est de réduire les risques liés à une mise en production. En fournissant au plus tôt un retour sur la qualité du code, les tests et en faisant du déploiement un process simple et répétable. Le déploiement cesse ainsi d’être un évènement exceptionnel et devient fréquent.\nUn bon pipeline est divisé en 3 macro-étapes :\nL’intégration continue (CI) est une pratique de développement logiciel où, après un merge des modifications du code dans un référentiel central (Git). Chaque modification (commit) déclenche une construction et un test automatisé, fournissant des retours aux développeurs. La livraison continue (CD) consiste à produire un artefact à partir du code, prêt à être déployé et potentiellement déposé sur un référentiel type Artifactory. Le déploiement continue (CD) consiste à automatiser l’ensemble du processus de mise en production logicielle, y compris la provision de l’infrastructure. D’autres étapes peuvent être ajoutées en fonction des besoins, comme un alerting. Mais le but premier d’un CI/CD et de s’assurer que le code soit testé et parte en production.\nLes différents stage d’une CI/CD Un pipeline CI/CD est divisé en “stages”, où chaque “stage” accomplit une série de tâches spécifiques. Nous allons voir les étapes essentielles d’un pipeline CI/CD.\nTrigger Un bon pipeline doit pouvoir se déclencher de manière automatique quand du code est commit et push sur le dépôt.\nCela peut se faire en configurant l’outil de CI/CD pour récupérer les changements sur le Git à intervalles réguliers ou encore en configurant un Webhook pour notifier l’outil de CI quand un développeur push du code.\nCheckout Durant cette étape, la CI va récupérer le code à partir d’un dépôt Git. Elle reçoit différentes informations et notamment quel commit à déclencher le pipeline.\nLe pipeline checkout le code source à ce commit et démarre le process.\nCompile Quality Linter Tests Packaging Delivery / Deployment Références https://www.tutorialworks.com/cicd-pipeline-stages/ ","description":"","tags":["ci/cd"],"title":"CI/CD","uri":"/devops/ci-cd/index.html"},{"content":"The CSS Reset /* 1. Use a more-intuitive box-sizing model. */ *, *::before, *::after { box-sizing: border-box; } /* 2. Remove default margin */ * { margin: 0; } /* 3. Allow percentage-based heights in the application */ html, body { height: 100%; } /* Typographic tweaks! 4. Add accessible line-height 5. Improve text rendering */ body { line-height: 1.5; -webkit-font-smoothing: antialiased; } /* 6. Improve media defaults */ img, picture, video, canvas, svg { display: block; max-width: 100%; } /* 7. Remove built-in form typography styles */ input, button, textarea, select { font: inherit; } /* 8. Avoid text overflows */ p, h1, h2, h3, h4, h5, h6 { overflow-wrap: break-word; } /* 9. Create a root stacking context */ #root, #__next { isolation: isolate; } Références https://meyerweb.com/eric/tools/css/reset/ https://www.joshwcomeau.com/css/custom-css-reset/ ","description":"","tags":["css"],"title":"CSS Reset","uri":"/developpement/frontend/css-scss/css-reset/index.html"},{"content":" Raccourcis clavier ","description":"","tags":null,"title":"Figma","uri":"/design/figma/index.html"},{"content":"Ce document vise a donner une méthode pour sauvegarder les fichiers de config de sa machine.\nInitialisation du repository Commencer par créer un bare-repository Git .dotfiles afin de pouvoir versionner les fichiers souhaités\ngit init --bare $HOME/.dotfiles Puis créer un alias dotfiles afin de faciliter l’utilisation de ce repository\nalias dotfiles='/usr/bin/git --git-dir=$HOME/.dotfiles/ --work-tree=$HOME' Configurer git pour qu’il n’affiche pas les fichiers non inclus\ndotfiles config --local status.showUntrackedFiles no Il peut être utile de créer une branche par ordinateur\ndotfiles checkout -b bureau Finir par configurer le dépôt distant et tout pousser dedans\ndotfiles remote add origin git@mondomain.org:monorg/dotfile.git dotfiles push dotfiles push --set-upstream origin bureau Warning Attention, il ne faut pas pousser des données critiques sur des repository publiques, ni même sur des repos privés hébergés sur des sites publiques comme Github, Gitlab ou Bitbucket. Par exemple des clef privée ssh, ou des tokens d’api…\nUtilisation Pour l’utilisation courante avec des exemples utiles :\ndotfiles status dotfiles add .vimrc dotfiles commit -m \"Add vimrc\" dotfiles add .bashrc dotfiles commit -m \"Add bashrc\" dotfiles add .bash_aliases dotfiles commit -m \"Add .bash_aliases\" dotfiles add .zshrc dotfiles commit -m \"Add .zshrc\" dotfiles add .ssh/config dotfiles commit -m \"Add .ssh config\" dotfiles add .screenrc dotfiles commit -m \"Add .screenrc\" dotfiles add .kube/config dotfiles commit -m \"Add kubectl config\" dotfiles add .gitconfig .git-credentials dotfiles commit -m \"Add git config\" dotfiles add .aws/config .aws/credentials .aws/shell/awsshellrc .aws/shell/history dotfiles commit -m \"Add aws config\" Restauration des dotfiles sur un ordinateur Il faut commencer par créer l’alias comme dans la section d’initalisation\nalias dotfiles='/usr/bin/git --git-dir=$HOME/.dotfiles/ --work-tree=$HOME' Puis récuperer le repository\ngit clone --bare git@mondomain.org:monorg/dotfile.git $HOME/.dotfiles Et enfin passer sur la bonne branche\ndotfiles checkout bureau Note Afin d’éviter les problèmes de perte de données avec les fichiers en conflits ou installés de base, on va les copier dans un répertoire pour les sauvegarder.\nmkdir -p .dotfile-backup \u0026\u0026 \\ dotfiles checkout bureau 2\u003e\u00261 | egrep \"\\s+\\.\" | awk {'print $1'} | \\ xargs -I{} mv {} .dotfile-backup/{} et comme on a déplacé les fichiers en conflit, on peut re-lancer le checkout\ndotfiles checkout bureau Branches différentes Si on ne veut pas melanger ses fichiers de configurations mais qu’on souhaite tout versionner dans son repo\nIl faut creer une autre branche vide home\ndotfiles checkout --orphan home dotfiles add .bash_aliases dotfiles commit .bash_aliases dotfiles push --set-upstream origin home Ajouter ensuite tous les fichiers comme décrit au début.\nRéférences doc doc doc ","description":"","tags":["workspace","dotfiles"],"title":"Gestion des fichiers de config","uri":"/workspace/dotfiles/index.html"},{"content":" Présentation Helm est un gestionnaire de paquet et un outil de templating pour Kubernetes.\nQuickstart ","description":"","tags":null,"title":"Helm","uri":"/devops/kubernetes/helm/index.html"},{"content":"Ce document détaille la procédure d’installation et de mise en service d’un serveur sous Ubuntu.\nTéléchargement de l’image et création de la clé USB bootable sur MAC Téléchargement de l’ISO L’ISO de la distribution Linux Ubuntu Server est téléchargeable sur ici.\nConversion de l’ISO en IMG Sous MAC, il est nécessaire de convertir l’image au format ISO en format IMG afin de pouvoir la copier sur une clé USB bootable. Il faut ensuite renommer le fichier parce que MacOS ajoute .dmg à la fin du nom.\nhdiutil convert -format UDRW -o ~/path/to/target.img ~/path/to/ubuntu.iso mv ~/path/to/target.img.dmg ~/path/to/target.img Copie de l’image sur la clé USB Commencer par récupérer la liste des disques du MAC avec la commande :\ndiskutil list Repérer la clé USB parmis tous les disques présentés et la démonter avec la commande :\ndiskutil unmountDisk /dev/diskN Copier ensuite le contenu de l’image sur la clé USB à l’aide de l’utilisaire dd :\nsudo dd if=/path/to/downloaded.img of=/dev/rdiskN bs=1m Une fois la copie terminée, la clé USB peut être éjectée.\ndiskutil eject /dev/diskN L’installation du système peut ensuite se faire de manière classique sur le serveur. Il est cependant important de choisir l’installation d’un serveur SSH comme openssh en même temps que l’installation du système.\nDésactivation de la mise en veille automatique à la fermeture du capôt (Portable uniquement) Si le serveur est un ancien PC portable, il est nécessaire de désactiver la mise en veille automatique de celui-ci. 2 possibilités en fonction du modèle :\nlogind.conf libdtn Si le fichier /etc/systemd/logind.conf existe, il faut l’éditer et ajouter ou modifier la ligne HandleLidSwitch=ignore.\nSi le fichier /etc/acpi/event/lidbtn existe, il faut l’éditer et commenter les 2 lignes ‘action’ et ’event’ (ajoutes un # devant).\nConfiguration de SSH Copie de la clé SSH et ajout aux authorized_keys On commence par transférer avec SCP les clés SSH (privée et publique) sur le serveur.\nscp ~/.ssh/id_rsa [host]:~/.ssh/ scp ~/.ssh/id_rsa.pub [host]:~/.ssh/ Puis on ajoute la clé publique aux authorized_keys afin de pouvoir désactiver l’authentification par mot de passe.\ncat ~/.ssh/id_rsa.pub \u003e ~/.ssh/authorized_keys Désactivation de l’authentification par mot de passe pour SSH Pour ce faire, la configuration du serveur SSH se trouve dans un fichier nommé sshd_config.\nsudo vim /etc/ssh/sshd_config Il suffit ensuite de passer la valeur de 3 paramètres à “no”:\nChallengeResponseAuthentication no PasswordAuthentication no UsePAM no Puis redémarrer les démon SSH pour appliquer la nouvelle configuration :\nsudo /etc/init.d/ssh restart Installation de Zsh et Oh My Zsh Zsh est disponible sur les dépôts officiels et s’installe avec la commande : sudo apt-get install zsh Il faut ensuite indiquer au système d’utiliser Zsh par défaut en utilisant l’outil chsh : sudo chsh -s /bin/zsh On peut ensuite installer Oh My Zsh avec la commande : sh -c \"$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\" Mise en place des dotfiles La récupération des dotfiles sur le serveur se fait avec la commande :\ngit clone --bare --branch server git@github.com:quentinpigne/dotfiles.git $HOME/.dotfiles À ce stade, la récupération des dotfiles reste incomplète du fait de conflits avec des fichiers déjà présents (comme .zshrc par exemple).\nOn va commencer par ajouter l’alias dotfiles au fichier .zshrc :\necho \"alias dotfiles='/usr/bin/git --git-dir=$HOME/.dotfiles/ --work-tree=$HOME'\" \u003e\u003e .zshrc source .zshrc Puis on configure Git pour qu’il n’affiche pas les fichiers non inclus :\ndotfiles config --local status.showUntrackedFiles no Pour finir, on reset les dotfiles afin de supprimer les fichiers en conflit puis on re-checkout la branche server.\ndotfiles reset --hard HEAD dotfiles checkout server Plus d’informations sur la page dédiée aux dotfiles.\nInstallation de NVim Il faut être sûr que software-properties-common est installé.\nsudo add-apt-repository ppa:neovim-ppa/unstable sudo apt-get update sudo apt-get install neovim On va ensuite installer la distribution AstroNvim avec la commande :\ngit clone --depth 1 https://github.com/AstroNvim/AstroNvim ~/.config/nvim Installation de NVM et de NodeJS NVM permet d’installer et d’utiliser différentes versions de NodeJS. Il s’installe avec la commande suivante :\nPROFILE=/dev/null bash -c 'curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bash' Installation de Docker Il faut être sûr que ca-certificates, curl et gnupg sont installés.\nOn commence par ajouter la clé GPG officielle de Docker :\nsudo install -m 0755 -d /etc/apt/keyrings curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg sudo chmod a+r /etc/apt/keyrings/docker.gpg Puis on ajoute le repository correspondants à la distribution Ubuntu du système :\necho \\ \"deb [arch=\"$(dpkg --print-architecture)\" signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\ \"$(. /etc/os-release \u0026\u0026 echo \"$VERSION_CODENAME\")\" stable\" | \\ sudo tee /etc/apt/sources.list.d/docker.list \u003e /dev/null Et enfin, on installe les paquets de Docker :\ndocker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin Il est ensuite nécessaire d’ajouter l’utilisateur au groupe docker afin d’avoir les bonnes permissions.\nsudo usermod -aG docker $USER ","description":"","tags":["workspace","server","ubuntu"],"title":"Installation d'un serveur Ubuntu","uri":"/workspace/linux/server/index.html"},{"content":"Création du projet Un projet Angular peut se présenter sous deux structures différentes. Une structure “classique” qui ne comprend qu’un unique projet ou bien un workspace pouvant contenir plusieurs applications ou librairies (aussi appelé “monorepo”)\nStructure ‘classique’ ng new [application-name] --routing --style scss --prefix [prefix] Workspace vide + application (monorepo) ng new [project-name] --create-application false ng generate application [application-name] --routing --style scss --prefix [prefix] Info Si le projet est créé dans un dépôt Git existant, il faut utiliser l’option --skip-git afin de spécifier au CLI d’Angular de ne pas initialiser de dépôt Git.\nIl peut aussi être utile de spécifier le package manager à utiliser à l’aide de l’option --package-manager.\nDans des cas plus rares, l’option --new-project-root permet de spécifier le nom du dossier dans lequel les nouvelles applications devront être générées.\nAjout d’ESLint et de Prettier Installation d’ESLint Il est possible d’ajouter facilement ESLint à un projet Angular en executant le schematic fourni :\nng add @angular-eslint/schematics Cela aura pour effet d’installer les dépendances nécessaires et créer le(s) fichier(s) de configuration associé(s).\nInstallation de Prettier Commencer par installer la package prettier ainsi que les deux plugins nécessaires à son intégration avec ESLint npm install --save-dev prettier eslint-config-prettier eslint-plugin-prettier Créer un fichier .prettierrc.json à la racine du projet { \"printWidth\": 120, \"singleQuote\": true, \"trailingComma\": \"all\", \"bracketSpacing\": true, \"overrides\": [ { \"files\": \".editorconfig\", \"options\": { \"parser\": \"yaml\" } } ] } Exemple de configuration ESLint pour workspace multi-projets racine projet { \"root\": true, \"ignorePatterns\": [\"projects/**/*\"], \"overrides\": [ { \"files\": [\"*.ts\"], \"extends\": [ \"plugin:@typescript-eslint/recommended\", \"plugin:@typescript-eslint/recommended-requiring-type-checking\", \"plugin:@angular-eslint/recommended\", \"plugin:@angular-eslint/template/process-inline-templates\", \"plugin:prettier/recommended\" ], \"rules\": {} }, { \"files\": [\"*.html\"], \"extends\": [\"plugin:@angular-eslint/template/recommended\"], \"rules\": {} } ] } { \"extends\": \"../../.eslintrc.json\", \"ignorePatterns\": [\"!**/*\"], \"overrides\": [ { \"files\": [\"*.ts\"], \"parserOptions\": { \"project\": [ \"./tsconfig.lib.json\", \"./tsconfig.spec.json\" ] }, \"rules\": { \"@typescript-eslint/no-inferrable-types\": \"off\", \"@typescript-eslint/no-empty-function\": \"off\", \"@angular-eslint/no-output-native\": \"off\", \"@angular-eslint/directive-selector\": [ \"error\", { \"type\": \"attribute\", \"prefix\": \"ui\", \"style\": \"camelCase\" } ], \"@angular-eslint/component-selector\": [ \"error\", { \"type\": [\"element\", \"attribute\"], \"prefix\": \"ui\", \"style\": \"kebab-case\" } ] } } ] } Ajout de Stylelint Commencer par installer la package stylelint ainsi que sa configuration standard npm install --save-dev stylelint stylelint-config-standard Créer un fichier .stylelintrc.json à la racine du projet { \"extends\": \"stylelint-config-standard\" } Ajout de Commitlint Commencer par installer la package commitlint ainsi que sa configuration standard npm install -g @commitlint/cli @commitlint/config-conventional Créer un fichier commitlint.config.js à la racine du projet module.exports = { extends: ['@commitlint/config-conventional'] } Ajout de Husky Husky est un outil qui permet de gérer facilement les Hooks Git en exécutant des scripts au format Node.js\nInstallation Il peut s’installer de manière automatique grâce au script d’initialisation\nnpx husky-init \u0026\u0026 npm install Mais aussi de manière manuelle en exécutant une suite de commandes :\nnpm install husky --save-dev npx husky install npm set-script prepare \"husky install\" Création de hooks Il est nécessaire des hooks afin d’exécuter les linters, les tests au commit et/ou au push. Pour ajouter une commande à un hook ou en créer un nouveau, utiliser la commande husky add \u003cfile\u003e [cmd]\nAjout de Storybook Storybook est un outil qui peut s’avérer très utile pour visualiser et tester ses composants en isolation. Il s’installe très facilement en exécutant le script d’init :\nnpx storybook init ","description":"","tags":["angular"],"title":"Mise en place d'un projet","uri":"/developpement/frontend/angular/project-setup/index.html"},{"content":"Cette rubrique présente les différents articles liés à l’environnement de travail.\nGestion des fichiers de config Linux Installation d'un serveur Ubuntu Windows ","description":"","tags":null,"title":"Poste de travail","uri":"/workspace/index.html"},{"content":" Bases du langage ","description":"","tags":null,"title":"Python","uri":"/developpement/backend/python/index.html"},{"content":"Zoom Shift + 0 : Zoom 100% Shift + 1 : Fit layer to screen Shift + 2 : Zoom in the selected frame Hide/Show Shift + R : Hide/Show Rulers Control + G : Hide/Show Layout Grids Tools P : Pen V : Move T : Text tool H : Hand I : Color picker Go to Option + 1 : Go to layers menu Option + 2 : Go to components menu For Windows, use Alt instead of Option\nCopy/Paste styles Option + Command + C : Copy style Option + Command + V : Paste style For Windows, use Ctrl + Shift instead of Option + Command\nGroup/Ungroup Command + C : Group selection Command + Shift + V : Ungroup selection For Windows, use Ctrl instead of Command\n","description":"","tags":["figma"],"title":"Raccourcis clavier","uri":"/design/figma/shortcuts/index.html"},{"content":" C4 Model ","description":"","tags":null,"title":"Architecture","uri":"/architecture/index.html"},{"content":" CSS Reset ","description":"","tags":null,"title":"CSS - SCSS","uri":"/developpement/frontend/css-scss/index.html"},{"content":" CSS - SCSS CSS Reset Angular Mise en place d'un projet Organisation des fichiers Vues et manipulations du DOM NgRx Migration de Karma vers Jest Librairies à points d'entrée multiples ","description":"","tags":null,"title":"Front-end","uri":"/developpement/frontend/index.html"},{"content":" Présentation ","description":"","tags":null,"title":"Jenkins","uri":"/devops/jenkins/index.html"},{"content":" Installation d'un serveur Ubuntu ","description":"","tags":null,"title":"Linux","uri":"/workspace/linux/index.html"},{"content":"src +-- app | +-- modules | | +-- home | | | +-- components | | | | +-- ... | | | +-- pages | | | | +-- ... | | | +-- home-store | | | | home.actions.ts | | | | home.reducers.ts | | | | home.effects.ts | | | | home.selectors.ts | | | | home.state.ts | | | | home-store.module.ts | | | home.routing.module.ts | | | home.module.ts | +-- core | | +-- core-store | | | +-- actions | | | | user.actions.ts | | | | index.ts | | | +-- reducers | | | | user.reducer.ts | | | | index.ts | | | +-- effects | | | | user.effects.ts | | | +-- selectors | | | | user.selectors.ts | | | core-store.module.ts | | +-- shell | | | +-- components | | | | +-- header | | | | | header.component.[ts|spec.ts|html|scss] | | | | +-- footer | | | | | footer.component.[ts|spec.ts|html|scss] | | | shell.module.ts | | | shell.component.[ts|spec.ts|html|scss] | | +-- authentication | | +-- services | | +-- ... | | core.module.ts | +-- shared | | +-- componentes | | +-- directives | | +-- pipes | | shared.module.ts | app.module.ts | app-routing.module.ts | app.component.ts | app.component.spec.ts | app.component.scss | app.component.html +-- assets +-- environments | environment.prod.ts | environment.ts index.html main.ts polyfills.ts styles.scss test.ts Modules Les modules sont un groupements de pages similaires fonctionnellement. Ils servent au découpage de l’application en vue du Lazy-loading\nPages Les pages sont un groupements de composants dont l’organisation est calqué sur la navigation. A chaque page correspond une route au niveau du RoutingModule\nComposants Un composant est une unité atomique représentant un élément d’une page\n","description":"","tags":["angular"],"title":"Organisation des fichiers","uri":"/developpement/frontend/angular/files-organization/index.html"},{"content":"Classes Création et instanciation d’une classe Un classe se crée à l’aide du mot clé class puis s’instencie avec la méthode new.\nclass MaClasse ... end object = MaClasse.new puts object.inspect #\u003cMaClasse:id\u003e Variables d’instance et constructeur En Ruby, les variables d’instance sont symbolisées par un @ et sont définit directement au niveau du constructeur, lui-même définit avec la méthode initialize.\nclass MaClasse def initialize(var1, var2) @var1 = var1 @var2 = var2 end end Méthodes d’instance Les méthodes d’instance se définissent au sein de la classe comme des méthodes classiques et suivent les même conventions. (nommage, ? si renvoie booléen, ! si modifie l’objet…)\nclass MaClasse def une_methode \u003cinstructions\u003e end end object = MaClasse.new object.une_methode Il est possible d’appeler une autre méthode d’instance depuis une méthode comme on appellerait une fonction depuis l’exterieur de la classe. (Pas de this)\nclass MaClasse def une_methode(var) \u003cinstructions\u003e end def une_autre_methode \u003cinstructions\u003e une_methode(var) \u003cinstructions\u003e end end Setter et Getter Methode naïve class MaClasse def initialize(var) @var = var end def var() @var end def var=(var) @var = var end end object = MaClasse.new object.var = \"test\" puts object.var Utilisation de attr_accessor, attr_reader et attr_writer class MaClasse attr_accessor :var def initialize(var) @var = var end end object = MaClasse.new object.var = \"test\" puts object.var Ces 3 méthodes sont en fait des méthodes de classes qui permettent de créer les getter et setter qui est appelée statiquement à l’intérieur de la classe.\nMéthodes privées Les méthodes privées doivent être déclarées après le mot-clé private. Elles restent accessibles à l’intérieur de la classe.\nclass MaClasse private def une_methode(var) \u003cinstructions\u003e end end Méthodes et Variables de classe Méthodes de classe Les méthodes de classe ne sont pas rattachées à une instance de la classe et se déclarent avec le mot-clé self.\nclass MaClasse def self.methode_classe \u003cinstructions\u003e end end puts MaClasse.methode_classe Pour appeler une méthode de classe depuis une méthode d’instance, il faut utiliser self.class.\u003cnom_methode\u003e.\nclass MaClasse def self.methode_classe \u003cinstructions\u003e end def une_methode self.class.methode_classe end end Variables de classe Les variables de classe se déclarent avec @@. Dans les méthodes de classe ou d’instance, on accède toujours aux variables de classe directement.\nclass MaClasse @@variable_classe = 'test' def self.methode_classe \"#{@@variable_classe}\" end def une_methode \"#{@@variable_classe}\" end end puts MaClasse.methode_classe Ouverture des classes En Ruby, les classes restent toujours ouvertes, il est donc possible de les modifier après leur déclaration.\nSoit en créant une méthode de classe à l’exterieur de celle-ci :\nclass MaClasse def une_methode \u003cinstructions\u003e end end def MaClass.methode_classe \u003cinstructions\u003e end Soit en réutilisant la même déclaration :\nclass MaClasse def une_methode \u003cinstructions\u003e end end class MaClasse def self.methode_classe \u003cinstructions\u003e end end Il est ainsi possible de “modifier” les méthodes internes à Ruby comme les méthodes de la classe String par exemple…\nMéthodes “spéciales” et opérateurs methode class La méthode class, appelée sur un objet, renvoie le Class de cet objet.\ns = \"Ceci est un texte\" s.class # String \u003c et \u003e Il est possible d’implémenter les opérateurs de supériorité et d’infériorité sur des objets en définissant ces méthodes qui prennent chacune l’élément sur lequel s’applique la comparaison :\nclass MaClass def \u003c(elem) \u003cinstructions\u003e end end L’héritage L’héritage se fait en Ruby avec le symbole \u003c.\nclass BaseClass ... end class HeritedClass \u003c BaseClass ... end Ainsi, HeritedClass “hérite” de toutes les méthodes et tous les attributs de BaseClass. Et il est aussi possible d’en ajouter de nouveaux ou de les surcharger. Dans ce cas, la méthode parente est accessible via le mot-clé super.\nWarning En Ruby, super correspond bien à la méthode parente et non à l’objet parent. De plus, utiliser super appelle la méthode (par défaut, avec les même paramètres que la méthode surchargée).\nclass HeritedClass \u003c BaseClass def method(param) method_value = super # équivalent : method_value = super(param) other_method_value = super(other_param) ... end end Info De la même manière que la méthode class, appeler class.superclass donne des informations sur la classe de base. Si on remonte dans la hiérarchie, toutes les classe de base héritent de Object qui, elle-même, hérite de BaseObject.\nLes exceptions Lancement d’une exception En Ruby, une exception se lève avec la méthode raise.\ndef method raise if error # unhandled exception raise \"Il y a une erreur\" if error # RuntimeError avec message raise SpecificError \"Il y a une erreur\" if error # SpecificError avec message end Capture d’une exception Une exception peut être capturer entre un begin et un rescue (qui prend en paramètre le type d’exception qu’on veut capturer) :\nbegin method rescue SpecificError =\u003e e puts e.to_s end Execution de code même si erreur Le mot-clé ensure permet d’exécuter du code même si une exception a été capturée :\nbegin method rescue SpecificError =\u003e e puts e.to_s ensure \u003cinstructions\u003e end Créer une classe d’erreur class MonErreur \u003c RuntimeError def initialize(msg = \"Message par défaut\") super end end def method raise MonErreur if error end En général, on ne fait pas hériter les classes d’erreur de RuntimeError mais on crée une classe Error pour le module, qui hérite de RuntimeError, et ensuite les classes d’erreur héritent de cette Error. Cela permet de capturer en une seule fois toutes les erreurs possibles pour le module en question au niveau du rescue :\nmodule MonModule class Erreur \u003c RuntimeError end class PremiereErreur \u003c Erreur def initialize(msg = \"Message par défaut\") super end end class DeuxiemeErreur \u003c Erreur def initialize(msg = \"Message par défaut\") super end end def method raise PremiereErreur if error1 raise DeuxiemeErreur if error2 end end begin MonModule::method rescue MonModule::Erreur =\u003e e puts e.to_s end ","description":"","tags":["ruby","poo"],"title":"Programmation Orientée Objet","uri":"/developpement/backend/ruby/poo/index.html"},{"content":" Bases du langage Programmation Orientée Objet Modules, namespaces et mixins ","description":"","tags":null,"title":"Ruby","uri":"/developpement/backend/ruby/index.html"},{"content":" Back-end Python Bases du langage Ruby Bases du langage Programmation Orientée Objet Modules, namespaces et mixins Front-end CSS - SCSS CSS Reset Angular Mise en place d'un projet Organisation des fichiers Vues et manipulations du DOM NgRx Migration de Karma vers Jest Librairies à points d'entrée multiples ","description":"","tags":null,"title":"Développement","uri":"/developpement/index.html"},{"content":" Présentation Docker est un outil permettant de lancer des applications dans des environnements isolés appelés conteneurs.\n","description":"","tags":null,"title":"Docker","uri":"/devops/docker/index.html"},{"content":"Les modules Définition et création Il est possible de créer un module avec le mot-clé module.\nUn module fonctionne un peu comme une classe. À la différence qu’il ne peut ni être instancié ni hérité. Il peut en revanche contenir des constantes, des variables, des méthodes (toujours avec self) ou des classes.\nmodule MonModule MA_CONSTANTE = 1 def self.une_methode() ... end class MaClasse ... end end Inclusion de modules tiers Tous les modules ne sont pas inclus par defaut, il est possible d’inclure des modules tiers avec le mot-clé require.\nrequire 'date' Info L’inclusion avec le mot-clé require ne concerne que le gems installées globalement. Pour inclure un fichier dont le chemin est relatif au fichier courant, il faut utiliser le mot-clé require_relative.\nrequire_relative 'fichier_local' Namespaces Pour éviter les doublons de classes ou de méthodes, il est possible d’utiliser les modules comme des namespaces. Les classes et méthodes d’un module sont accessibles dans un autre module avec la syntaxe \u003cNomModule\u003e::. (Fonctionnement similaire aux namespaces C++)\nLe but des namespaces est de regrouper les classes liées à une même logique.\nMixins Le système de module permet aussi de faire de l’héritage “horizontal” car ils peuvent être inclus dans une class.\nmodule Feature def une_fonction_liee_a_la_feature ... end end class MaClasse include Feature ... end objet = MaClass.new puts objet.une_fonction_liee_a_la_feature Inclure un module dans une classe greffe automatiquement toutes les méthodes d’instance qui sont dans le module, au niveau de la classe.\nMéthode included Les modules ont tous une méthode de classe included. Si on la définit, cela permet de capturer à chaque fois qu’une module est inclus dans un sous-module ou dans une classe.\nmodule Feature def self.included(base) # base = classe dans laquelle le module est inclus puts base end end Il est ainsi possible de modifier la classe dynamiquement à l’inclusion d’un module :\nmodule Feature def self.included(base) # base = classe dans laquelle le module est inclus def base.une_nouvelle_methode ... end end end extend au lieu de include extend transfère les méthodes d’instance en méthode classe.\nmodule Feature def une_methode ... end end class MaClasse extend Feature ... end puts MaClass.une_methode extend peut aussi être appelé depuis une instance de classe :\nmodule Feature def une_methode ... end end class MaClasse ... end objet = MaClasse.new objet.extend(Feature) puts objet.une_methode Cela a pour effet de rajouter les méthodes du mixin dans l’instance, mais uniquement pour cette instance.\nDe la même manière que include a un hook included permettant de capturer quand un module est inclus dans une classe. Il existe un hook extended qui permet de capturer quand un module est étendu par une classe.\n","description":"","tags":["ruby"],"title":"Modules, namespaces et mixins","uri":"/developpement/backend/ruby/modules/index.html"},{"content":"Vues en Angular En Angular, une vue (View) est le plus petit groupe d’éléments qui sont créés et détruits ensemble et dont le rendu est défini par une ou plusieurs directives. La philosophie d’Angular encourage les dévelopeurs à voir l’application comme une composition de vues, et non un assemblage d’éléments HTML.\nUne vue est définie par une classe Component et son template associé. Elle est représentée par une instance de ViewRef associée à un composant. Une vue qui est directement issue d’un composant est appelée HostView. Une hiérarchie de vues est ainsi établie.\nLes propriétés des éléments d’une vue peuvent être modifiées dynamiquement (suite à une action utilisateur par exemple). Cependant la structure (leur nombre et leur ordre) des éléments d’une vue ne peut pas changer. Il est possible de modifier la structure des éléments en insérant, déplaçant ou supprimant des vues imbriquées à l’intérieur de conteneurs de vues spécifiques.\nLes hiérarchies de vues sont chargées et déchargées dynamiquement en naviguant dans l’application, sous le contrôle du routeur.\nHiérarchie de vues L’assemblage de vues associées défini une arborescence sur lesquelles il est possible d’agir. La vue racine est référencée en tant que host view d’un composant. Une host view est la racine d’une arborescence de embedded views, collecté dans un conteneur de vue ViewContainerRef attaché à un élément d’ancrage dans le composant hôte. La hiérarchie des vues est un élément clé de la détection des changements en Angular.\nL’arborescence de vues n’implique pas d’arborescence de composants. Les embedded views dans le contexte d’une arborescence particulière peuvent être des host views d’autres composants. Ces composants peuvent être dans le même NgModule que le composant hôte, ou appartenir à d’autres NgModules.\nViewRef ViewRef est une classe abstraite représentant une vue Angular. Angular supporte 2 types de vues :\nles EmbeddedView qui sont liées à un Template les HostView qui sont liées à un Component Références https://indepth.dev/posts/1052/exploring-angular-dom-manipulation-techniques-using-viewcontainerref https://indepth.dev/posts/1134/working-with-dom-in-angular-unexpected-consequences-and-optimization-techniques ","description":"","tags":["angular","dom","view"],"title":"Vues et manipulations du DOM","uri":"/developpement/frontend/angular/dom_manipulation/index.html"},{"content":"","description":"","tags":null,"title":"Windows","uri":"/workspace/windows/index.html"},{"content":" CI/CD Jenkins Docker Kubernetes Helm ","description":"","tags":null,"title":"DevOps","uri":"/devops/index.html"},{"content":" Helm Présentation Kubernetes (souvent abrégé K8S) est un orchestrateur de conteneurs.\n","description":"","tags":null,"title":"Kubernetes","uri":"/devops/kubernetes/index.html"},{"content":"","description":"","tags":["angular","redux","state management"],"title":"NgRx","uri":"/developpement/frontend/angular/ngrx/index.html"},{"content":" Figma Raccourcis clavier ","description":"","tags":null,"title":"Design","uri":"/design/index.html"},{"content":"Angular est fourni par défaut avec Karma. Il est cependant très simple de passer de Karma à Jest.\nSupprimer Karma Commencer par supprimer les fichiers src/karma.conf.js et src/test.ts.\nPuis dans le fichier package.json, supprimer les dépendances suivantes dans devDependencies:\n\"karma\": \"*\", \"karma-chrome-launcher\": \"*\", \"karma-coverage-istanbul-reporter\": \"*\", \"karma-jasmine\": \"*\", \"karma-jasmine-html-reporter\": \"*\", Installer Jest Installer Jest dans le projet à l’aide de la commande suivante :\nnpm i -D jest @types/jest ts-jest @angular-builders/jest Ajouter un fichier nommé jest.config.js dans le même dossier que package.json\n/** jest.config.js */ module.exports = { collectCoverageFrom: [ '\u003crootDir\u003e/src/app/**/*.ts', '!\u003crootDir\u003e/src/app/**/index.ts', '!\u003crootDir\u003e/src/app/**/*.module.ts' ], coverageDirectory: 'coverage', coverageReporters: [ 'lcov', 'text-summary' ], testPathIgnorePatterns: [ '\u003crootDir\u003e/coverage/', '\u003crootDir\u003e/dist/', '\u003crootDir\u003e/e2e/', '\u003crootDir\u003e/node_modules/', '\u003crootDir\u003e/src/app/*.(js|scss)' ], testMatch: [ '\u003crootDir\u003e/src/app/*.spec.ts', '\u003crootDir\u003e/src/app/**/*.spec.ts' ] }; Puis dans le fichier src/tsconfig.spec.json:\nRemplcez “jasmine” et “node” par “jest” dans la liste types Ajouter \"module\": \"commonjs\" aux compilerOptions Supprimer “test.js” de la liste files Le fichier src/tsconfig.spec.json doit maintenant ressembler à ça:\n{ \"extends\": \"./tsconfig.json\", \"compilerOptions\": { \"module\": \"commonjs\", \"outDir\": \"./out-tsc/spec\", \"types\": [ \"jest\" ], }, \"files\": [ \"polyfills.ts\" ], \"include\": [ \"**/*.spec.ts\", \"**/*.d.ts\" ] } Dans src/tsconfig.app.json supprimer “test.ts” de la liste exclude.\nEt pour finir, modifier le fichier angular.json. Changer la section projects[your-project].architect.test de manière à ce quelle ressemble à cela:\n\"test\": { \"builder\": \"@angular-builders/jest:run\", \"options\": {} }, À la suite des ces changements, il peut être nécessaire de supprimer le dossier node_modules et de lancer un npm install à nouveau.\nIl devrait maintenant être possible de lancer les tests avec la commande npm test.\nIl est aussi possible d’ajouter un script au package.json pour lancer la suite de tests directement avec la couverture de code.\n... \"scripts\": { ... \"test:cov\": \"ng test --coverage\" }, ... Et lancer le avec la commande npm run test:cov.\nLe rapport de couverture de code doit être présent dans le dossier coverage à la racine du projet.\nRéférences https://medium.com/angular-in-depth/migrate-your-angular-library-to-jest-faba9579591a https://dev.to/this-is-angular/migrate-from-jasmine-to-jest-and-testing-in-angular-286i ","description":"","tags":["tests unitaires","jest","angular"],"title":"Migration de Karma vers Jest","uri":"/developpement/frontend/angular/karma2jest/index.html"},{"content":"Points d’entrée multiples Références https://sandroroth.com/blog/angular-library ","description":"","tags":["angular"],"title":"Librairies à points d'entrée multiples","uri":"/developpement/frontend/angular/multi-entrypoints/index.html"},{"content":"","description":"","tags":null,"title":"angular","uri":"/tags/angular/index.html"},{"content":" Mise en place d'un projet Organisation des fichiers Vues et manipulations du DOM NgRx Migration de Karma vers Jest Librairies à points d'entrée multiples ","description":"","tags":null,"title":"Angular","uri":"/developpement/frontend/angular/index.html"},{"content":"","description":"","tags":null,"title":"architecture-as-code","uri":"/tags/architecture-as-code/index.html"},{"content":"","description":"","tags":null,"title":"Categories","uri":"/categories/index.html"},{"content":"","description":"","tags":null,"title":"ci/cd","uri":"/tags/ci/cd/index.html"},{"content":"","description":"","tags":null,"title":"css","uri":"/tags/css/index.html"},{"content":"","description":"","tags":null,"title":"diagrams","uri":"/tags/diagrams/index.html"},{"content":"","description":"","tags":null,"title":"dom","uri":"/tags/dom/index.html"},{"content":"","description":"","tags":null,"title":"dotfiles","uri":"/tags/dotfiles/index.html"},{"content":"","description":"","tags":null,"title":"figma","uri":"/tags/figma/index.html"},{"content":"","description":"","tags":null,"title":"jest","uri":"/tags/jest/index.html"},{"content":"","description":"","tags":null,"title":"Ma documentation","uri":"/index.html"},{"content":"","description":"","tags":null,"title":"poo","uri":"/tags/poo/index.html"},{"content":"","description":"","tags":null,"title":"python","uri":"/tags/python/index.html"},{"content":"","description":"","tags":null,"title":"redux","uri":"/tags/redux/index.html"},{"content":"","description":"","tags":null,"title":"ruby","uri":"/tags/ruby/index.html"},{"content":"","description":"","tags":null,"title":"server","uri":"/tags/server/index.html"},{"content":"","description":"","tags":null,"title":"state management","uri":"/tags/state-management/index.html"},{"content":"","description":"","tags":null,"title":"Tags","uri":"/tags/index.html"},{"content":"","description":"","tags":null,"title":"tests unitaires","uri":"/tags/tests-unitaires/index.html"},{"content":"","description":"","tags":null,"title":"ubuntu","uri":"/tags/ubuntu/index.html"},{"content":"","description":"","tags":null,"title":"view","uri":"/tags/view/index.html"},{"content":"","description":"","tags":null,"title":"workspace","uri":"/tags/workspace/index.html"}]