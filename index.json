[{"content":" Ruby Bases du langage Programmation Orientée Objet ","description":"","tags":null,"title":"Back-end","uri":"/developpement/backend/"},{"content":"Variables Types Integer 1234 String 'string' Boolean trueet false Méthodes utiles pour convertir les types to_i : conversion en Integer to_s : conversion en String Vérifier qu’une variable est d’un certain type En Ruby, on vérifie rarement le type d’une variable, on utilise plutôt la méthode respond_to? afin de vérifier qu’on puisse lui appliquer une certaine méthode.\ndef toUp(text) if text.respond_to?(:to_s) text.to_s.upcase end end Déclaration d’une variable En Ruby les variables ont un typage faible et peuvent changer de type à volonté\nmaVariable = 'Chaine de caractères' Affichage variable dans une string :\n\"Ceci est une chaine de caractères contenant une #{variable}\" Il est possible de déclarer des variables de manière globale en la plaçant en dehors de tout bloc et en utilisant le signe $\n$variableGlobale = \"Hello, world !\" Et pour finir, il est possible de déclarer des constantes, en écrivant leur nom tout en majuscule.\nMA_CONSTANTE = 1 Entrées/Sorties puts affiche une chaîne de caractères à l’écran (avec saut de ligne)\nprint affiche une chaîne de caractères à l’écran (sans saut de ligne)\ngets récupère une entrée utilisateur (garde le saut de ligne de fin) utliser la méthode chomp pour supprimer le saut de ligne final\nnom = gets.chomp puts \"Bonjour #{nom} !\" Commentaires Commentaires sur une ligne En Ruby, un commentaire sur une ligne est défini par le caractère #.\n# Ceci est un commentaire Commentaires sur plusieurs lignes Il est possible de définir un bloc de commentaires pouvant tenir sur plusieurs lignes à l’aide de =begin et =end.\n=begin Ceci est un bloc de commentaires pouvant tenir sur plusieurs lignes. =end Conditions Bloc if-elsif-else if \u003ccondition\u003e instruction elsif \u003ccondition\u003e instruction else instruction end unless condition est équivalent à if !condition\nUne condition if peut s’écrire sur une ligne\nputs \"Condition vraie\" if \u003ccondition\u003e puts \"Condition fausse\" unless \u003ccondition\u003e Bloc case-when var = 1 case var when 1 puts \"ok\" else puts \"ko\" end Il existe une version raccourcie :\nvar = 1 case var when 1 then puts \"ok\" end Ternaire En Ruby, les conditions ternaires s’écrivent comme dans tous les autres langages :\nputs a \u003c b ? \"ok\" : \"ko\" Operateurs conditionnels || renvoie la 1ère valeur si truthy et la 2ème sinon.\na = false b = \"Salut\" puts a || b # Salut a = \"Hello\" puts a || b # Hello Affectation conditionnelle a = false a ||= \"Valeur par defaut\" puts a # Valeur par defaut a = \"Hello\" a ||= \"Valeur par defaut\" puts a # Hello Boucles Boucle While while \u003ccondition\u003e # until !\u003ccondition\u003e ... end Boucle For for num in 1..10 # 1..10 = [1, 10] et 1...10 = [1, 10[ puts num end Sauter une itération for num in 1..10 next if num == 3 puts num end Boucle Loop (Infinie) loop do ... break if \u003ccondition\u003e end Tableaux Déclaration d’un tableau et accès à un élément tableau = [1, 2, '3', '4'] # Un tableau peut contenir des éléments de types différents puts tableau[0] # 1 Ajout d’un élément à un tableau Pour ajouter un élément à un tableau, on peut utiliser la concaténation d’un autre tableau avec l’opérateur +, les chevrons («) ou la méthode push.\ntableau += ['5'] tableau \u003c\u003c '6' tableau.push '7' Retrait d’un élément du tableau On utilise la méthode pop de la classe Array\ntableau.pop Méthodes collect et map Ce sont deux fonctions identiques qui executent un bloc pour chaque élément d’un tableau et retournent le tableau resultant.\nHash Déclaration d’un Hash et accès à un élément hash = { 'key' =\u003e 'value' } puts hash['key'] # value puts hash['inexistingKey'] # nil Syntaxe plus moderne utilisant implicitement des symboles\nhash = { key: 'value' } hash[:key] # value puts hash[:inexistingKey] # nil En utilisant le constructeur et en spécifiant une valeur par défaut\nhash = Hash.new(0) puts hash[:inexistingKey] # 0 Ajout d’un élément dans un Hash hash['otherKey'] = 'otherValue' hash[:otherKey] = 'otherValue' Itérateurs Méthode times 3.times do |num| puts num end Méthode each array.each do |value| ... end hash.each do |key, value| ... end Fonctions Définir une fonction def nom_fonction(param) return param end En l’absence d’instruction return, une fonction renverra le résultat de sa dernière instruction.\nEn Ruby, on ne teste pas le type d’un paramètre mais on tente directement de le caster.\nConventions de nommage Les caractères spéciaux sont autorisés dans les noms de fonction ainsi que les symboles comme ‘+’, ‘-’… Traditionnellement, les fonctions possédant ces symboles implémentes les opérateurs correspondants.\n? : retourne un boolean ! : modifie l’objet Paramètres optionnels Il est possible de rendre un paramètre optionnel en précisant sa valeur par defaut\ndef nom_fonction(param = \"Valeur par defaut\") return param end Liste de paramètres def nom_fonction(*params) puts params.inspect end Il est toujours possible de passer des paramètres “isolés” en les mettant avant la liste.\nProcs et Blocs Blocs Passer un bloc a une fonction Un bloc peut être passé à une fonction à l’aide du mot-clé yield.\ndef test puts \"A first text\" yield puts \"A third text\" end test { puts \"A second text\" } Un bloc peut être appelé plusieurs fois en mettant plusieurs yield dans la fonction.\nWarning A partir du moment où on met un yield dans une fonction, celle-ci va obligatoirement attendre un paramètre de type bloc.\nPasser un paramètre à un bloc Il est possible de passer un ou plusieurs paramètre(s) à yield. Ils seront automatiquement passés au bloc :\ndef test puts \"A first text\" yield(\"A second text\") puts \"A third text\" end test { |text| puts text } La limite des blocs est qu’ils ne peuvent pas être sauvegardés dans des variables. Empêcher ainsi de pouvoir les réutiliser à plusieurs endroits.\nProcs On peut voir les procs comme des blocs qu’on peut sauvegarder.\nCréation d’un Proc On peut créer un Proc avec Proc.new auquel on passe un bloc. Et on peut le sauvegarder dans une variable.\nvar = Proc.new { \u003cinstructions\u003e } Passage d’un Proc à une fonction Pour être passé en tant que bloc à une fonction, un Proc doit être ‘converti’ en bloc. Cela se fait avec le signe \u0026.\nmonProc = Proc.new { \u003cinstructions\u003e } a = [1, 2, 3] a.map!(\u0026monProc) Appel direct d’un `Proc`` Il est possible d’appeler à n’importe quel moment un Proc en utilisant la méthode call :\nmonProc = Proc.new { |param| \u003cinstructions\u003e } monProc.call(\"param\") Récupérer dans une fonction un bloc sous forme de Proc Il est possible de récupérer un bloc sous forme de Proc dans une fonction à l’aide du même signe \u0026 :\ndef maFonction(\u0026bloc) # ici, bloc est un Proc bloc.call(\"param\") end maFonction { |param| \u003cinstructions\u003e } Info Contrairement aux blocs, il est possible de passer plusieurs Proc à une fonction !\nLambda En Ruby, un lambda est très similaire à un Proc.\nPour créer un lambda, il suffit de remplacer le Proc.new par lambda et lui passer un bloc.\nmonLambda = lambda { |param| \u003cinstructions\u003e } puts monLambda.inspect # On se rend compte ici qu'un lambda est un Proc particulier Il s’utilise ensuite de la même façon qu’un Proc.\nDifférences entre Proc et lambda Un lambda vérifie le nombre de paramètres fournis, alors que le Proc n’effectue aucune vérification sur les paramètres. Dans un lambda, le return retourne au sein du bloc, alors que dans un Proc, il le comprend comme un return “classique”. def a_lambda a = lambda { return \"Salut\" } a.call # équivalent \"Salut\" return \"Au revoir\" end def a_proc a = Proc.new { return \"Salut\" } a.call # équivalent return \"Salut\" return \"Au revoir\" end a_lambda # Au revoir a_proc # Salut Nouvelle syntaxe du lambda monLambda = -\u003e(\u003cparam\u003e) { \u003cinstructions\u003e } Syntaxe raccourcie pour un appel de méthode sur chaque élément passé à un bloc a = [\"1\", \"2\", 3] a.map! { |n| n.to_i } # Syntaxe \"classique\" a.map!(\u0026:to_i) # Syntaxe raccourcie ","description":"","tags":["ruby"],"title":"Bases du langage","uri":"/developpement/backend/ruby/basics/"},{"content":"The CSS Reset /* 1. Use a more-intuitive box-sizing model. */ *, *::before, *::after { box-sizing: border-box; } /* 2. Remove default margin */ * { margin: 0; } /* 3. Allow percentage-based heights in the application */ html, body { height: 100%; } /* Typographic tweaks! 4. Add accessible line-height 5. Improve text rendering */ body { line-height: 1.5; -webkit-font-smoothing: antialiased; } /* 6. Improve media defaults */ img, picture, video, canvas, svg { display: block; max-width: 100%; } /* 7. Remove built-in form typography styles */ input, button, textarea, select { font: inherit; } /* 8. Avoid text overflows */ p, h1, h2, h3, h4, h5, h6 { overflow-wrap: break-word; } /* 9. Create a root stacking context */ #root, #__next { isolation: isolate; } Références https://meyerweb.com/eric/tools/css/reset/ https://www.joshwcomeau.com/css/custom-css-reset/ ","description":"","tags":["css"],"title":"CSS Reset","uri":"/developpement/frontend/css-scss/css-reset/"},{"content":" Raccourcis clavier ","description":"","tags":null,"title":"Figma","uri":"/design/figma/"},{"content":"Ce document vise a donner une méthode pour sauvegarder les fichiers de config de sa machine.\nInitialisation du repository Commencer par créer un bare-repository Git .dotfiles afin de pouvoir versionner les fichiers souhaités\ngit init --bare $HOME/.dotfiles Puis créer un alias dotfiles afin de faciliter l’utilisation de ce repository\nalias dotfiles='/usr/bin/git --git-dir=$HOME/.dotfiles/ --work-tree=$HOME' Configurer git pour qu’il n’affiche pas les fichiers non inclus\ndotfiles config --local status.showUntrackedFiles no Il peut être utile de créer une branche par ordinateur\ndotfiles checkout -b bureau Finir par configurer le dépôt distant et tout pousser dedans\ndotfiles remote add origin git@mondomain.org:monorg/dotfile.git dotfiles push dotfiles push --set-upstream origin bureau Warning Attention, il ne faut pas pousser des données critiques sur des repository publiques, ni même sur des repos privés hébergés sur des sites publiques comme Github, Gitlab ou Bitbucket. Par exemple des clef privée ssh, ou des tokens d’api…\nUtilisation Pour l’utilisation courante avec des exemples utiles :\ndotfiles status dotfiles add .vimrc dotfiles commit -m \"Add vimrc\" dotfiles add .bashrc dotfiles commit -m \"Add bashrc\" dotfiles add .bash_aliases dotfiles commit -m \"Add .bash_aliases\" dotfiles add .zshrc dotfiles commit -m \"Add .zshrc\" dotfiles add .ssh/config dotfiles commit -m \"Add .ssh config\" dotfiles add .screenrc dotfiles commit -m \"Add .screenrc\" dotfiles add .kube/config dotfiles commit -m \"Add kubectl config\" dotfiles add .gitconfig .git-credentials dotfiles commit -m \"Add git config\" dotfiles add .aws/config .aws/credentials .aws/shell/awsshellrc .aws/shell/history dotfiles commit -m \"Add aws config\" Restauration des dotfiles sur un ordinateur Il faut commencer par créer l’alias comme dans la section d’initalisation\nalias dotfiles='/usr/bin/git --git-dir=$HOME/.dotfiles/ --work-tree=$HOME' Puis récuperer le repository\ngit clone --bare git@mondomain.org:monorg/dotfile.git $HOME/.dotfiles Et enfin passer sur la bonne branche\ndotfiles checkout bureau Note Afin d’éviter les problèmes de perte de données avec les fichiers en conflits ou installés de base, on va les copier dans un répertoire pour les sauvegarder.\nmkdir -p .dotfile-backup \u0026\u0026 \\ dotfiles checkout bureau 2\u003e\u00261 | egrep \"\\s+\\.\" | awk {'print $1'} | \\ xargs -I{} mv {} .dotfile-backup/{} et comme on a déplacé les fichiers en conflit, on peut re-lancer le checkout\ndotfiles checkout bureau Branches différentes Si on ne veut pas melanger ses fichiers de configurations mais qu’on souhaite tout versionner dans son repo\nIl faut creer une autre branche vide home\ndotfiles checkout --orphan home dotfiles add .bash_aliases dotfiles commit .bash_aliases dotfiles push --set-upstream origin home Ajouter ensuite tous les fichiers comme décrit au début.\nRéférences doc doc doc ","description":"","tags":["workspace","dotfiles"],"title":"Gestion des fichiers de config","uri":"/workspace/dotfiles/"},{"content":"Création du projet Un projet Angular peut se présenter sous deux structures différentes. Une structure “classique” qui ne comprend qu’un unique projet ou bien un workspace pouvant contenir plusieurs applications ou librairies (aussi appelé “monorepo”)\nStructure ‘classique’ ng new [application-name] --routing --style scss --prefix [prefix] Workspace vide + application (monorepo) ng new [project-name] --create-application false ng generate application [application-name] --routing --style scss --prefix [prefix] Info Si le projet est créé dans un dépôt Git existant, il faut utiliser l’option --skip-git afin de spécifier au CLI d’Angular de ne pas initialiser de dépôt Git.\nIl peut aussi être utile de spécifier le package manager à utiliser à l’aide de l’option --package-manager.\nDans des cas plus rares, l’option --new-project-root permet de spécifier le nom du dossier dans lequel les nouvelles applications devront être générées.\nAjout d’ESLint et de Prettier Installation d’ESLint Il est possible d’ajouter facilement ESLint à un projet Angular en executant le schematic fourni :\nng add @angular-eslint/schematics Cela aura pour effet d’installer les dépendances nécessaires et créer le(s) fichier(s) de configuration associé(s).\nInstallation de Prettier Commencer par installer la package prettier ainsi que les deux plugins nécessaires à son intégration avec ESLint npm install --save-dev prettier eslint-config-prettier eslint-plugin-prettier Créer un fichier .prettierrc.json à la racine du projet { \"printWidth\": 120, \"singleQuote\": true, \"trailingComma\": \"all\", \"bracketSpacing\": true, \"overrides\": [ { \"files\": \".editorconfig\", \"options\": { \"parser\": \"yaml\" } } ] } Exemple de configuration ESLint pour workspace multi-projets racine projet { \"root\": true, \"ignorePatterns\": [\"projects/**/*\"], \"overrides\": [ { \"files\": [\"*.ts\"], \"extends\": [ \"plugin:@typescript-eslint/recommended\", \"plugin:@typescript-eslint/recommended-requiring-type-checking\", \"plugin:@angular-eslint/recommended\", \"plugin:@angular-eslint/template/process-inline-templates\", \"plugin:prettier/recommended\" ], \"rules\": {} }, { \"files\": [\"*.html\"], \"extends\": [\"plugin:@angular-eslint/template/recommended\"], \"rules\": {} } ] } { \"extends\": \"../../.eslintrc.json\", \"ignorePatterns\": [\"!**/*\"], \"overrides\": [ { \"files\": [\"*.ts\"], \"parserOptions\": { \"project\": [ \"./tsconfig.lib.json\", \"./tsconfig.spec.json\" ] }, \"rules\": { \"@typescript-eslint/no-inferrable-types\": \"off\", \"@typescript-eslint/no-empty-function\": \"off\", \"@angular-eslint/no-output-native\": \"off\", \"@angular-eslint/directive-selector\": [ \"error\", { \"type\": \"attribute\", \"prefix\": \"ui\", \"style\": \"camelCase\" } ], \"@angular-eslint/component-selector\": [ \"error\", { \"type\": [\"element\", \"attribute\"], \"prefix\": \"ui\", \"style\": \"kebab-case\" } ] } } ] } Ajout de Stylelint Commencer par installer la package stylelint ainsi que sa configuration standard npm install --save-dev stylelint stylelint-config-standard Créer un fichier .stylelintrc.json à la racine du projet { \"extends\": \"stylelint-config-standard\" } Ajout de Commitlint Commencer par installer la package commitlint ainsi que sa configuration standard npm install -g @commitlint/cli @commitlint/config-conventional Créer un fichier commitlint.config.js à la racine du projet module.exports = { extends: ['@commitlint/config-conventional'] } Ajout de Husky Husky est un outil qui permet de gérer facilement les Hooks Git en exécutant des scripts au format Node.js\nInstallation Il peut s’installer de manière automatique grâce au script d’initialisation\nnpx husky-init \u0026\u0026 npm install Mais aussi de manière manuelle en exécutant une suite de commandes :\nnpm install husky --save-dev npx husky install npm set-script prepare \"husky install\" Création de hooks Il est nécessaire des hooks afin d’exécuter les linters, les tests au commit et/ou au push. Pour ajouter une commande à un hook ou en créer un nouveau, utiliser la commande husky add \u003cfile\u003e [cmd]\nAjout de Storybook Storybook est un outil qui peut s’avérer très utile pour visualiser et tester ses composants en isolation. Il s’installe très facilement en exécutant le script d’init :\nnpx storybook init ","description":"","tags":["angular"],"title":"Mise en place d'un projet","uri":"/developpement/frontend/angular/project-setup/"},{"content":"Cette rubrique présente les différents articles liés à l’environnement de travail.\nGestion des fichiers de config Linux Windows ","description":"","tags":null,"title":"Poste de travail","uri":"/workspace/"},{"content":"Zoom Shift + 0 : Zoom 100% Shift + 1 : Fit layer to screen Shift + 2 : Zoom in the selected frame Hide/Show Shift + R : Hide/Show Rulers Control + G : Hide/Show Layout Grids Tools P : Pen V : Move T : Text tool H : Hand I : Color picker Go to Option + 1 : Go to layers menu Option + 2 : Go to components menu For Windows, use Alt instead of Option\nCopy/Paste styles Option + Command + C : Copy style Option + Command + V : Paste style For Windows, use Ctrl + Shift instead of Option + Command\nGroup/Ungroup Command + C : Group selection Command + Shift + V : Ungroup selection For Windows, use Ctrl instead of Command\n","description":"","tags":["figma"],"title":"Raccourcis clavier","uri":"/design/figma/shortcuts/"},{"content":" Bases du langage Programmation Orientée Objet ","description":"","tags":null,"title":"Ruby","uri":"/developpement/backend/ruby/"},{"content":" CSS Reset ","description":"","tags":null,"title":"CSS - SCSS","uri":"/developpement/frontend/css-scss/"},{"content":" Back-end Ruby Bases du langage Programmation Orientée Objet Front-end CSS - SCSS CSS Reset Angular Mise en place d'un projet Organisation des fichiers Vues et manipulations du DOM Migration de Karma vers Jest ","description":"","tags":null,"title":"Développement","uri":"/developpement/"},{"content":" CSS - SCSS CSS Reset Angular Mise en place d'un projet Organisation des fichiers Vues et manipulations du DOM Migration de Karma vers Jest ","description":"","tags":null,"title":"Front-end","uri":"/developpement/frontend/"},{"content":"","description":"","tags":null,"title":"Linux","uri":"/workspace/linux/"},{"content":"src +-- app | +-- modules | | +-- home | | | +-- components | | | | +-- ... | | | +-- pages | | | | +-- ... | | | +-- home-store | | | | home.actions.ts | | | | home.reducers.ts | | | | home.effects.ts | | | | home.selectors.ts | | | | home.state.ts | | | | home-store.module.ts | | | home.routing.module.ts | | | home.module.ts | +-- core | | +-- core-store | | | +-- actions | | | | user.actions.ts | | | | index.ts | | | +-- reducers | | | | user.reducer.ts | | | | index.ts | | | +-- effects | | | | user.effects.ts | | | +-- selectors | | | | user.selectors.ts | | | core-store.module.ts | | +-- shell | | | +-- components | | | | +-- header | | | | | header.component.[ts|spec.ts|html|scss] | | | | +-- footer | | | | | footer.component.[ts|spec.ts|html|scss] | | | shell.module.ts | | | shell.component.[ts|spec.ts|html|scss] | | +-- authentication | | +-- services | | +-- ... | | core.module.ts | +-- shared | | +-- componentes | | +-- directives | | +-- pipes | | shared.module.ts | app.module.ts | app-routing.module.ts | app.component.ts | app.component.spec.ts | app.component.scss | app.component.html +-- assets +-- environments | environment.prod.ts | environment.ts index.html main.ts polyfills.ts styles.scss test.ts Modules Les modules sont un groupements de pages similaires fonctionnellement. Ils servent au découpage de l’application en vue du Lazy-loading\nPages Les pages sont un groupements de composants dont l’organisation est calqué sur la navigation. A chaque page correspond une route au niveau du RoutingModule\nComposants Un composant est une unité atomique représentant un élément d’une page\n","description":"","tags":["angular"],"title":"Organisation des fichiers","uri":"/developpement/frontend/angular/files-organization/"},{"content":"Classes Création et instanciation d’une classe Un classe se crée à l’aide du mot clé class puis s’instencie avec la méthode new.\nclass MaClasse ... end object = MaClasse.new puts object.inspect #\u003cMaClasse:id\u003e Variables d’instance et constructeur En Ruby, les variables d’instance sont symbolisées par un @ et sont définit directement au niveau du constructeur, lui-même définit avec la méthode initialize.\nclass MaClasse def initialize(var1, var2) @var1 = var1 @var2 = var2 end end Méthodes d’instance Les méthodes d’instance se définissent au sein de la classe comme des méthodes classiques et suivent les même conventions. (nommage, ? si renvoie booléen, ! si modifie l’objet…)\nclass MaClasse def uneMethode \u003cinstructions\u003e end end object = MaClasse.new object.uneMethode Il est possible d’appeler une autre méthode d’instance depuis une méthode comme on appellerait une fonction depuis l’exterieur de la classe. (Pas de this)\nclass MaClasse def uneMethode(var) \u003cinstructions\u003e end def uneAutreMethode \u003cinstructions\u003e uneMethode(var) \u003cinstructions\u003e end end Setter et Getter Methode naïve class MaClasse def initialize(var) @var = var end def var() @var end def var=(var) @var = var end end object = MaClasse.new object.var = \"test\" puts object.var Utilisation de attr_accessor, attr_reader et attr_writer class MaClasse attr_accessor :var def initialize(var) @var = var end end object = MaClasse.new object.var = \"test\" puts object.var Ces 3 méthodes sont en fait des méthodes de classes qui permettent de créer les getter et setter qui est appelée statiquement à l’intérieur de la classe.\nMéthodes privées Les méthodes privées doivent être déclarées après le mot-clé private. Elles restent accessibles à l’intérieur de la classe.\nclass MaClasse private def uneMethode(var) \u003cinstructions\u003e end end Méthodes et Variables de classe Méthodes de classe Les méthodes de classe ne sont pas rattachées à une instance de la classe et se déclarent avec le mot-clé self.\nclass MaClasse def self.methodeClasse \u003cinstructions\u003e end end puts MaClasse.methodeClasse Pour appeler une méthode de classe depuis une méthode d’instance, il faut utiliser self.class.\u003cnom_methode\u003e.\nclass MaClasse def self.methodeClasse \u003cinstructions\u003e end def uneMethode self.class.methodeClasse end end Variables de classe Les variables de classe se déclarent avec @@. Dans les méthodes de classe ou d’instance, on accède toujours aux variables de classe directement.\nclass MaClasse @@variableClasse = 'test' def self.methodeClasse \"#{@@variableClasse}\" end def uneMethode \"#{@@variableClasse}\" end end puts MaClasse.methodeClasse Ouverture des classes En Ruby, les classes restent toujours ouvertes, il est donc possible de les modifier après leur déclaration.\nSoit en créant une méthode de classe à l’exterieur de celle-ci :\nclass MaClasse def uneMethode \u003cinstructions\u003e end end def MaClass.methodeClasse \u003cinstructions\u003e end Soit en réutilisant la même déclaration :\nclass MaClasse def uneMethode \u003cinstructions\u003e end end class MaClasse def self.methodeClasse \u003cinstructions\u003e end end Il est ainsi possible de “modifier” les méthodes internes à Ruby comme les méthodes de la classe String par exemple…\nMéthodes “spéciales” et opérateurs methode class La méthode class, appelée sur un objet, renvoie le Class de cet objet.\ns = \"Ceci est un texte\" s.class # String \u003c et \u003e Il est possible d’implémenter les opérateurs de supériorité et d’infériorité sur des objets en définissant ces méthodes qui prennent chacune l’élément sur lequel s’applique la comparaison :\nclass MaClass def \u003c(elem) \u003cinstructions\u003e end end L’héritage L’héritage se fait en Ruby avec le symbole \u003c.\nclass BaseClass ... end class HeritedClass \u003c BaseClass ... end Ainsi, HeritedClass “hérite” de toutes les méthodes et tous les attributs de BaseClass. Et il est aussi possible d’en ajouter de nouveaux ou de les surcharger. Dans ce cas, la méthode parente est accessible via le mot-clé super.\nWarning En Ruby, super correspond bien à la méthode parente et non à l’objet parent. De plus, utiliser super appelle la méthode (par défaut, avec les même paramètres que la méthode surchargée).\nclass HeritedClass \u003c BaseClass def method(param) methodValue = super # équivalent : baseMathodValue = super(param) otherMethodValue = super(otherParam) ... end end Info De la même manière que la méthode class, appeler class.superclass donne des informations sur la classe de base. Si on remonte dans la hiérarchie, toutes les classe de base héritent de Object qui, elle-même, hérite de BaseObject.\n","description":"","tags":["ruby","poo"],"title":"Programmation Orientée Objet","uri":"/developpement/backend/ruby/poo/"},{"content":" Figma Raccourcis clavier ","description":"","tags":null,"title":"Design","uri":"/design/"},{"content":"Vues en Angular En Angular, une vue (View) est la pierre angulaire constitutrice de toute application front. C’est le plus petit groupe d’éléments qui sont créés et détruits ensemble. La philosophie d’Angular encourage les dévelopeurs à voir l’application comme une composition de view, et non un assemblage d’éléments HTML.\nViewRef ViewRef est une classe abstraite représentant une vue Angular. Angular supporte 2 types de vues :\nles EmbeddedView qui sont liées à un Template les HostView qui sont liées à un Component Références https://indepth.dev/posts/1052/exploring-angular-dom-manipulation-techniques-using-viewcontainerref https://indepth.dev/posts/1134/working-with-dom-in-angular-unexpected-consequences-and-optimization-techniques ","description":"","tags":["angular","dom"],"title":"Vues et manipulations du DOM","uri":"/developpement/frontend/angular/dom_manipulation/"},{"content":"","description":"","tags":null,"title":"Windows","uri":"/workspace/windows/"},{"content":"Angular est fourni par défaut avec Karma. Il est cependant très simple de passer de Karma à Jest.\nSupprimer Karma Commencer par supprimer les fichiers src/karma.conf.js et src/test.ts.\nPuis dans le fichier package.json, supprimer les dépendances suivantes dans devDependencies:\n\"karma\": \"*\", \"karma-chrome-launcher\": \"*\", \"karma-coverage-istanbul-reporter\": \"*\", \"karma-jasmine\": \"*\", \"karma-jasmine-html-reporter\": \"*\", Installer Jest Installer Jest dans le projet à l’aide de la commande suivante :\nnpm i -D jest @types/jest ts-jest @angular-builders/jest Ajouter un fichier nommé jest.config.js dans le même dossier que package.json\n/** jest.config.js */ module.exports = { collectCoverageFrom: [ '\u003crootDir\u003e/src/app/**/*.ts', '!\u003crootDir\u003e/src/app/**/index.ts', '!\u003crootDir\u003e/src/app/**/*.module.ts' ], coverageDirectory: 'coverage', coverageReporters: [ 'lcov', 'text-summary' ], testPathIgnorePatterns: [ '\u003crootDir\u003e/coverage/', '\u003crootDir\u003e/dist/', '\u003crootDir\u003e/e2e/', '\u003crootDir\u003e/node_modules/', '\u003crootDir\u003e/src/app/*.(js|scss)' ], testMatch: [ '\u003crootDir\u003e/src/app/*.spec.ts', '\u003crootDir\u003e/src/app/**/*.spec.ts' ] }; Puis dans le fichier src/tsconfig.spec.json:\nRemplcez “jasmine” et “node” par “jest” dans la liste types Ajouter \"module\": \"commonjs\" aux compilerOptions Supprimer “test.js” de la liste files Le fichier src/tsconfig.spec.json doit maintenant ressembler à ça:\n{ \"extends\": \"./tsconfig.json\", \"compilerOptions\": { \"module\": \"commonjs\", \"outDir\": \"./out-tsc/spec\", \"types\": [ \"jest\" ], }, \"files\": [ \"polyfills.ts\" ], \"include\": [ \"**/*.spec.ts\", \"**/*.d.ts\" ] } Dans src/tsconfig.app.json supprimer “test.ts” de la liste exclude.\nEt pour finir, modifier le fichier angular.json. Changer la section projects[your-project].architect.test de manière à ce quelle ressemble à cela:\n\"test\": { \"builder\": \"@angular-builders/jest:run\", \"options\": {} }, À la suite des ces changements, il peut être nécessaire de supprimer le dossier node_modules et de lancer un npm install à nouveau.\nIl devrait maintenant être possible de lancer les tests avec la commande npm test.\nIl est aussi possible d’ajouter un script au package.json pour lancer la suite de tests directement avec la couverture de code.\n... \"scripts\": { ... \"test:cov\": \"ng test --coverage\" }, ... Et lancer le avec la commande npm run test:cov.\nLe rapport de couverture de code doit être présent dans le dossier coverage à la racine du projet.\nRéférences https://medium.com/angular-in-depth/migrate-your-angular-library-to-jest-faba9579591a https://dev.to/this-is-angular/migrate-from-jasmine-to-jest-and-testing-in-angular-286i ","description":"","tags":["tests unitaires","jest","angular"],"title":"Migration de Karma vers Jest","uri":"/developpement/frontend/angular/karma2jest/"},{"content":"","description":"","tags":null,"title":"angular","uri":"/tags/angular/"},{"content":" Mise en place d'un projet Organisation des fichiers Vues et manipulations du DOM Migration de Karma vers Jest ","description":"","tags":null,"title":"Angular","uri":"/developpement/frontend/angular/"},{"content":"","description":"","tags":null,"title":"Categories","uri":"/categories/"},{"content":"","description":"","tags":null,"title":"css","uri":"/tags/css/"},{"content":"","description":"","tags":null,"title":"dom","uri":"/tags/dom/"},{"content":"","description":"","tags":null,"title":"dotfiles","uri":"/tags/dotfiles/"},{"content":"","description":"","tags":null,"title":"figma","uri":"/tags/figma/"},{"content":"","description":"","tags":null,"title":"jest","uri":"/tags/jest/"},{"content":"","description":"","tags":null,"title":"Ma documentation","uri":"/"},{"content":"","description":"","tags":null,"title":"poo","uri":"/tags/poo/"},{"content":"","description":"","tags":null,"title":"ruby","uri":"/tags/ruby/"},{"content":"","description":"","tags":null,"title":"Tags","uri":"/tags/"},{"content":"","description":"","tags":null,"title":"tests unitaires","uri":"/tags/tests-unitaires/"},{"content":"","description":"","tags":null,"title":"workspace","uri":"/tags/workspace/"}]